//! Display name generation utilities.
//!
//! This module provides functions for generating display names from items
//! and metadata. Display names are generated by the metadata's `ToDisplayName`
//! implementation, which controls the format and ordering of components.
//!
//! # Example
//!
//! For an item "808 Snare Top" matched to Drums > Electronic Kit > Snare:
//!
//! ```text
//! Display name: "808 Snare Top"
//! - "808" = variant metadata value
//! - "Snare" = most specific group name
//! - "Top" = MultiMic metadata value
//! ```
//!
//! # Usage
//!
//! ```ignore
//! use monarchy::display::to_display_name;
//!
//! let display = to_display_name(&item, &config);
//! println!("Display name: {}", display);
//! ```

use crate::{Config, Item, Metadata, ToDisplayName};

// region:    --- Display Name Generation

/// Format metadata as a display name using the item's metadata ToDisplayName implementation
///
/// This delegates to `item.derive_display_name()` which:
/// 1. Extracts prefixes and group names from matched_groups
/// 2. Calls `metadata.to_display_name()` to generate the display string
/// 3. Falls back to original input if no meaningful display name is generated
///
/// Note: The `_config` parameter is kept for API compatibility but not used.
/// The display name logic is controlled by the Metadata type's ToDisplayName implementation.
pub fn to_display_name<M: Metadata + ToDisplayName>(item: &Item<M>, _config: &Config<M>) -> String {
    item.derive_display_name()
}

/// Format a metadata value as a string for display
///
/// This handles enum variant wrappers and vector formats.
pub fn format_metadata_value<M: Metadata>(value: &M::Value) -> String {
    let value_str = format!("{:?}", value);

    // Remove enum variant wrapper if present (e.g., "MultiMic([\"In\"])" -> "In")
    // This is a simple heuristic - we might need a better way
    if let Some(start) = value_str.find('(')
        && let Some(end) = value_str.rfind(')')
    {
        let inner = &value_str[start + 1..end];
        // If it's a Vec format like ["In", "Out"], extract values
        if inner.starts_with('[') && inner.ends_with(']') {
            let content = &inner[1..inner.len() - 1];
            // Split by comma and clean up quotes
            let values: Vec<String> = content
                .split(',')
                .map(|s| s.trim().trim_matches('"').trim_matches('\'').to_string())
                .filter(|s| !s.is_empty())
                .collect();
            return values.join(" ");
        }
        // Otherwise, just return the inner content without quotes
        return inner.trim_matches('"').trim_matches('\'').to_string();
    }
    value_str
}

// endregion: --- Display Name Generation

// region:    --- Support Functions

/// Helper to find a group in the config by name (recursively searches nested groups)
#[allow(dead_code)]
pub fn find_group_in_config<'a, M: Metadata>(
    config: &'a Config<M>,
    name: &str,
) -> Option<&'a crate::Group<M>> {
    fn search_group<'a, M: Metadata>(
        group: &'a crate::Group<M>,
        name: &str,
    ) -> Option<&'a crate::Group<M>> {
        if group.name == name {
            return Some(group);
        }
        for nested in &group.groups {
            if let Some(found) = search_group(nested, name) {
                return Some(found);
            }
        }
        None
    }

    for group in &config.groups {
        if let Some(found) = search_group(group, name) {
            return Some(found);
        }
    }
    None
}

// endregion: --- Support Functions
