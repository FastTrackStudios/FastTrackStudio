# DAW HTTP Server Example

This example demonstrates a fully functional HTTP server for the DAW transport system using Axum. It showcases the composable protocol architecture and provides comprehensive testing.

## Features

- âœ… **RESTful HTTP API** with consistent JSON responses
- âœ… **Multiple handler patterns** (direct endpoints + generic action handlers)
- âœ… **Protocol discovery** endpoint listing all available paths
- âœ… **Comprehensive error handling** with standardized error responses
- âœ… **Full test coverage** including integration tests with real HTTP requests
- âœ… **Composable design** ready for extending to other domains (markers, media, mixer)

## Running the Server

```bash
# Start the HTTP server
cargo run --example http_server --features http-server
```

The server will start on `http://127.0.0.1:3000` and display available endpoints:

```
ðŸŽµ DAW HTTP Server starting on http://127.0.0.1:3000
ðŸ“‹ Available endpoints:
  GET  /health - Health check
  POST /transport/action - Generic transport actions
  POST /transport/async-action - Async transport actions
  POST /transport/query - Transport queries
  GET  /transport/paths - List all transport paths
  POST /transport/play - Direct play control
  GET  /transport/tempo - Get current tempo
  GET  /transport/state - Get full transport state
```

## API Endpoints

### Health Check
```bash
curl -X GET http://127.0.0.1:3000/health
# Response: {"success": true, "data": "OK", "error": null}
```

### Transport Control (Direct Endpoints)
```bash
# Start playback
curl -X POST http://127.0.0.1:3000/transport/play

# Pause playback
curl -X POST http://127.0.0.1:3000/transport/pause

# Stop playback
curl -X POST http://127.0.0.1:3000/transport/stop
```

### Transport Queries (Direct Endpoints)
```bash
# Get current tempo
curl -X GET http://127.0.0.1:3000/transport/tempo
# Response: {"success": true, "data": {"bpm": 120.0}, "error": null}

# Get full transport state
curl -X GET http://127.0.0.1:3000/transport/state
```

### Generic Action Handler
The generic action handler accepts JSON payloads with the action format generated by the `#[actions]` macro:

```bash
# Play action
curl -X POST http://127.0.0.1:3000/transport/action \
  -H "Content-Type: application/json" \
  -d '{"action": "Play"}'

# Set tempo action
curl -X POST http://127.0.0.1:3000/transport/action \
  -H "Content-Type: application/json" \
  -d '{"action": "SetTempo", "params": {"bpm": 140.0}}'

# Pause action
curl -X POST http://127.0.0.1:3000/transport/action \
  -H "Content-Type: application/json" \
  -d '{"action": "Pause"}'
```

### Transport Queries
```bash
# Get tempo via query handler
curl -X POST http://127.0.0.1:3000/transport/query \
  -H "Content-Type: application/json" \
  -d '{"action": "GetTempo"}'

# Check if playing
curl -X POST http://127.0.0.1:3000/transport/query \
  -H "Content-Type: application/json" \
  -d '{"action": "IsPlaying"}'
```

### Protocol Discovery
```bash
# List all available transport paths
curl -X GET http://127.0.0.1:3000/transport/paths
```

## Testing

### Unit Tests
```bash
# Run all example tests
cargo test --example http_server --features http-server

# Run specific test
cargo test --example http_server --features http-server test_health_check
```

### Integration Test
The `test_full_integration` test starts a real HTTP server and tests all endpoints:

```bash
# Run the comprehensive integration test
cargo test --example http_server --features http-server test_full_integration
```

This test:
1. âœ… Starts the server on a random port
2. âœ… Tests health check endpoint
3. âœ… Tests protocol discovery
4. âœ… Tests all direct control endpoints
5. âœ… Tests tempo queries and state retrieval
6. âœ… Tests generic action handlers with JSON payloads
7. âœ… Tests query handlers for transport state
8. âœ… Verifies state changes (e.g., tempo modifications)
9. âœ… Tests error cases (404 for invalid endpoints)
10. âœ… Automatically cleans up server process

### JSON Format Testing
To see the correct JSON formats for actions:

```bash
cargo run --example test_json_format
```

## API Response Format

All endpoints return a consistent JSON response format:

```json
{
  "success": boolean,
  "data": any | null,
  "error": string | null
}
```

**Success Response:**
```json
{
  "success": true,
  "data": "Mock: Playback started",
  "error": null
}
```

**Error Response:**
```json
{
  "success": false,
  "data": null,
  "error": "Invalid tempo: 999.0 BPM"
}
```

## Architecture

### Handler Patterns

The server demonstrates two handler patterns:

1. **Direct Endpoints** (`/transport/play`, `/transport/tempo`)
   - Simple, RESTful URLs
   - Type-safe handlers
   - Easy to cache and document

2. **Generic Action Handler** (`/transport/action`, `/transport/query`)
   - Accepts JSON action payloads
   - Leverages the macro-generated `TransportAction` enum
   - More flexible for complex operations

### State Management

- **Shared State**: Uses `Arc<RwLock<MockTransport>>` for thread-safe access
- **Async Handlers**: All handlers are async-compatible
- **Lock Efficiency**: Read locks for queries, write locks for mutations

### Extensibility

The server is designed for easy extension:

```rust
// Future domains can be added:
pub struct AppState {
    pub transport: Arc<RwLock<MockTransport>>,
    // pub markers: Arc<RwLock<dyn MarkersActions>>,
    // pub media: Arc<RwLock<dyn MediaActions>>,
    // pub mixer: Arc<RwLock<dyn MixerActions>>,
}

// And nested in the router:
Router::new()
    .nest("/transport", transport_router())
    // .nest("/markers", markers_router())
    // .nest("/media", media_router())
    // .nest("/mixer", mixer_router())
```

## Protocol Integration

This HTTP server leverages the protocol mapping system:

- **Path Discovery**: `/transport/paths` endpoint uses `get_all_paths()`
- **Consistent Naming**: HTTP paths follow RESTful conventions via `http_router!` macro
- **Type Safety**: All action variants are compile-time verified
- **Future Protocols**: OSC, MIDI, gRPC can use the same action definitions

## Error Handling

- **Transport Errors**: Converted to JSON error responses
- **HTTP Errors**: Standard status codes (400, 404, 500)
- **Validation**: Tempo and other parameter validation
- **Graceful Degradation**: Partial failures don't crash the server

## Performance Considerations

- **Async I/O**: Full async/await support with Tokio
- **Connection Pooling**: Axum handles connection management
- **JSON Streaming**: Efficient serialization with serde_json
- **Lock Contention**: Minimized lock scope in handlers

This example serves as a foundation for building production DAW control servers and demonstrates best practices for the composable protocol architecture.