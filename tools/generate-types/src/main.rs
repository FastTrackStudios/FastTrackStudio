//! TypeScript Type Generation Tool
//!
//! This tool generates TypeScript definitions from Rust types using ts-rs.
//! It exports all types marked with `#[ts(export)]` from the FastTrackStudio modules.

use anyhow::Result;
use std::env;
use std::fs;
use std::path::Path;
use ts_rs::TS;

// Import all the types we want to export
use primitives::{MusicalPosition, Position, TimePosition, TimeRange, TimeSignature};
use project::ProjectError;
use transport::{PlayState, RecordMode, Tempo, Transport};

// Import comprehensive app state types
use desktop_lib::state::{
    AppState, AppStateSnapshot, ProjectState, ProjectMetadata, AppPreferences,
    Theme, ProjectDefaults, AudioSettings, KeyboardShortcuts, UIState, Tool,
    WindowSize, RecentProjects, RecentProject
};

fn main() -> Result<()> {
    println!("ðŸŽµ FastTrackStudio TypeScript Type Generator");
    println!("==========================================");

    // Get the output directory from environment variable or use default
    let output_dir = env::var("TS_RS_EXPORT_DIR")
        .unwrap_or_else(|_| "../../apps/desktop/src/bindings".to_string());

    println!("ðŸ“ Output directory: {}", output_dir);

    // Create the output directory
    fs::create_dir_all(&output_dir)?;

    // Export all types
    println!("ðŸ“ Exporting types...");

    // Core primitive types
    PlayState::export()?;
    println!("   âœ… PlayState");

    RecordMode::export()?;
    println!("   âœ… RecordMode");

    Tempo::export()?;
    println!("   âœ… Tempo");

    Transport::export()?;
    println!("   âœ… Transport");

    MusicalPosition::export()?;
    println!("   âœ… MusicalPosition");

    TimePosition::export()?;
    println!("   âœ… TimePosition");

    Position::export()?;
    println!("   âœ… Position");

    TimeRange::export()?;
    println!("   âœ… TimeRange");

    TimeSignature::export()?;
    println!("   âœ… TimeSignature");

    ProjectError::export()?;
    println!("   âœ… ProjectError");

    // Comprehensive application state types
    AppState::export()?;
    println!("   âœ… AppState");

    AppStateSnapshot::export()?;
    println!("   âœ… AppStateSnapshot");

    ProjectState::export()?;
    println!("   âœ… ProjectState");

    ProjectMetadata::export()?;
    println!("   âœ… ProjectMetadata");

    AppPreferences::export()?;
    println!("   âœ… AppPreferences");

    Theme::export()?;
    println!("   âœ… Theme");

    ProjectDefaults::export()?;
    println!("   âœ… ProjectDefaults");

    AudioSettings::export()?;
    println!("   âœ… AudioSettings");

    KeyboardShortcuts::export()?;
    println!("   âœ… KeyboardShortcuts");

    UIState::export()?;
    println!("   âœ… UIState");

    Tool::export()?;
    println!("   âœ… Tool");

    WindowSize::export()?;
    println!("   âœ… WindowSize");

    RecentProjects::export()?;
    println!("   âœ… RecentProjects");

    RecentProject::export()?;
    println!("   âœ… RecentProject");

    // Generate an index.ts file that re-exports everything
    generate_index_file(&output_dir)?;
    println!("   âœ… index.ts (re-export file)");

    println!("\nðŸŽ‰ Successfully generated TypeScript types!");
    println!("ðŸ“ Types are available at: {}", output_dir);

    Ok(())
}

fn generate_index_file(output_dir: &str) -> Result<()> {
    let index_content = r#"// Auto-generated TypeScript types from Rust
// This file is generated by ts-rs. Do not edit manually.
//
// To regenerate these types, run:
// cargo xtask generate-types

// === MAIN APPLICATION STATE ===
// Complete application state - use this as your primary interface
export * from './AppState';
export * from './AppStateSnapshot';

// === PROJECT STATE ===
export * from './ProjectState';
export * from './ProjectMetadata';

// === APPLICATION PREFERENCES ===
export * from './AppPreferences';
export * from './Theme';
export * from './ProjectDefaults';
export * from './AudioSettings';
export * from './KeyboardShortcuts';

// === UI STATE ===
export * from './UIState';
export * from './Tool';
export * from './WindowSize';

// === RECENT PROJECTS ===
export * from './RecentProjects';
export * from './RecentProject';

// === CORE TRANSPORT TYPES ===
export * from './PlayState';
export * from './RecordMode';
export * from './Tempo';
export * from './Transport';

// === PRIMITIVE TYPES ===
export * from './MusicalPosition';
export * from './TimePosition';
export * from './Position';
export * from './TimeRange';
export * from './TimeSignature';

// === ERROR TYPES ===
export * from './ProjectError';

// === TYPE ALIASES ===
// Note: TimeRange conflicts with DOM TimeRanges, so we use module-qualified imports
// export type { TimeRange as TimeSelection };
// export type { TimeRange as LoopPoints };

// === USAGE EXAMPLES ===
// For complete application state:
// import { AppState, AppStateSnapshot } from './bindings';
//
// For specific components:
// import { Transport, ProjectState, UIState } from './bindings';
//
// For type-safe Tauri commands:
// import { AppStateSnapshot } from './bindings';
// const state: AppStateSnapshot = await invoke('get_app_state');
"#;

    let index_path = Path::new(output_dir).join("index.ts");
    fs::write(index_path, index_content)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_type_generation() {
        // Set a test output directory
        let temp_dir = std::env::temp_dir().join("fasttrack-test-types");
        std::env::set_var("TS_RS_EXPORT_DIR", temp_dir.to_str().unwrap());

        // Run the generation
        main().expect("Type generation should succeed");

        // Verify files exist
        let expected_files = [
            "PlayState.ts",
            "RecordMode.ts",
            "Tempo.ts",
            "Transport.ts",
            "MusicalPosition.ts",
            "TimePosition.ts",
            "Position.ts",
            "TimeRange.ts",
            "TimeSignature.ts",
            "ProjectError.ts",
            "index.ts",
        ];

        for file in &expected_files {
            let file_path = temp_dir.join(file);
            assert!(file_path.exists(), "File should exist: {:?}", file_path);
        }

        // Clean up
        std::fs::remove_dir_all(&temp_dir).ok();
    }
}
